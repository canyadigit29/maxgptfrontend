schema,function_name,definition
public,autofill_chunk_description,"CREATE OR REPLACE FUNCTION public.autofill_chunk_description()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  SELECT description INTO NEW.description
  FROM files
  WHERE id = NEW.file_id
  LIMIT 1;

  RETURN NEW;
END;
$function$
"
public,copy_to_chat_files,"CREATE OR REPLACE FUNCTION public.copy_to_chat_files()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO chat_files
  SELECT NEW.*;
  RETURN NEW;
END;
$function$
"
public,create_duplicate_messages_for_new_chat,"CREATE OR REPLACE FUNCTION public.create_duplicate_messages_for_new_chat(old_chat_id uuid, new_chat_id uuid, new_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO messages (user_id, chat_id, content, role, model, sequence_number, tokens, created_at, updated_at)
    SELECT new_user_id, new_chat_id, content, role, model, sequence_number, tokens, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
    FROM messages
    WHERE chat_id = old_chat_id;
END;
$function$
"
public,create_profile_and_workspace,"CREATE OR REPLACE FUNCTION public.create_profile_and_workspace()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    random_username TEXT;
BEGIN
    -- Generate a random username
    random_username := 'user' || substr(replace(gen_random_uuid()::text, '-', ''), 1, 16);

    -- Create a profile for the new user
    INSERT INTO public.profiles(user_id, anthropic_api_key, azure_openai_35_turbo_id, azure_openai_45_turbo_id, azure_openai_45_vision_id, azure_openai_api_key, azure_openai_endpoint, google_gemini_api_key, has_onboarded, image_url, image_path, mistral_api_key, display_name, bio, openai_api_key, openai_organization_id, perplexity_api_key, profile_context, use_azure_openai, username)
    VALUES(
        NEW.id,
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        FALSE,
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        FALSE,
        random_username
    );

    INSERT INTO public.workspaces(user_id, is_home, name, default_context_length, default_model, default_prompt, default_temperature, description, embeddings_provider, include_profile_context, include_workspace_instructions, instructions)
    VALUES(
        NEW.id,
        TRUE,
        'Home',
        4096,
        'gpt-4-turbo-preview', -- Updated default model
        'You are a friendly, helpful AI assistant.',
        0.5,
        'My home workspace.',
        'openai',
        TRUE,
        TRUE,
        ''
    );

    RETURN NEW;
END;
$function$
"
public,delete_message_including_and_after,"CREATE OR REPLACE FUNCTION public.delete_message_including_and_after(p_user_id uuid, p_chat_id uuid, p_sequence_number integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    DELETE FROM messages 
    WHERE user_id = p_user_id AND chat_id = p_chat_id AND sequence_number >= p_sequence_number;
END;
$function$
"
public,delete_messages_including_and_after,"CREATE OR REPLACE FUNCTION public.delete_messages_including_and_after(p_user_id uuid, p_chat_id uuid, p_sequence_number integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    DELETE FROM messages 
    WHERE user_id = p_user_id AND chat_id = p_chat_id AND sequence_number >= p_sequence_number;
END;
$function$
"
public,delete_old_assistant_image,"CREATE OR REPLACE FUNCTION public.delete_old_assistant_image()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  status INT;
  content TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    SELECT
      INTO status, content
      result.status, result.content
      FROM public.delete_storage_object_from_bucket('assistant_images', OLD.image_path) AS result;
    IF status <> 200 THEN
      RAISE WARNING 'Could not delete assistant image: % %', status, content;
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$function$
"
public,delete_old_file,"CREATE OR REPLACE FUNCTION public.delete_old_file()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  status INT;
  content TEXT;
BEGIN
  -- ðŸ§¹ Delete the physical file from Supabase Storage
  IF TG_OP = 'DELETE' THEN
    SELECT INTO status, content
      result.status, result.content
    FROM public.delete_storage_object_from_bucket('files', OLD.file_path) AS result;

    IF status <> 200 THEN
      RAISE WARNING 'Could not delete file: % %', status, content;
    END IF;
  END IF;

  -- ðŸ§¨ New: delete all related document_chunks for this file
  DELETE FROM document_chunks WHERE file_id = OLD.id;

  RETURN OLD;
END;
$function$
"
public,delete_old_message_images,"CREATE OR REPLACE FUNCTION public.delete_old_message_images()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  status INT;
  content TEXT;
  image_path TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    FOREACH image_path IN ARRAY OLD.image_paths
    LOOP
      SELECT
        INTO status, content
        result.status, result.content
        FROM public.delete_storage_object_from_bucket('message_images', image_path) AS result;
      IF status <> 200 THEN
        RAISE WARNING 'Could not delete message image: % %', status, content;
      END IF;
    END LOOP;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$function$
"
public,delete_old_profile_image,"CREATE OR REPLACE FUNCTION public.delete_old_profile_image()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  status INT;
  content TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    SELECT
      INTO status, content
      result.status, result.content
      FROM public.delete_storage_object_from_bucket('profile_images', OLD.image_path) AS result;
    IF status <> 200 THEN
      RAISE WARNING 'Could not delete profile image: % %', status, content;
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$function$
"
public,delete_old_workspace_image,"CREATE OR REPLACE FUNCTION public.delete_old_workspace_image()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  status INT;
  content TEXT;
BEGIN
  IF TG_OP = 'DELETE' THEN
    SELECT
      INTO status, content
      result.status, result.content
      FROM public.delete_storage_object_from_bucket('workspace_images', OLD.image_path) AS result;
    IF status <> 200 THEN
      RAISE WARNING 'Could not delete workspace image: % %', status, content;
    END IF;
  END IF;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$function$
"
public,delete_storage_object,"CREATE OR REPLACE FUNCTION public.delete_storage_object(bucket text, object text, OUT status integer, OUT content text)
 RETURNS record
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  project_url TEXT := 'https://knwpqgmpuvzemkvqlgof.supabase.co';
  service_role_key TEXT := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtud3BxZ21wdXZ6ZW1rdnFsZ29mIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0ODAxOTEwNywiZXhwIjoyMDYzNTk1MTA3fQ.uWMayDqL6djdBcRAL9vxF33RNBiyoKTxuRLQq4QsG1k';
  url TEXT := project_url || '/storage/v1/object/' || bucket || '/' || object;
BEGIN
  SELECT
      INTO status, content
           result.status::INT, result.content::TEXT
      FROM extensions.http((
    'DELETE',
    url,
    ARRAY[extensions.http_header('authorization','Bearer ' || service_role_key)],
    NULL,
    NULL)::extensions.http_request) AS result;
END;
$function$
"
public,delete_storage_object_from_bucket,"CREATE OR REPLACE FUNCTION public.delete_storage_object_from_bucket(bucket_name text, object_path text, OUT status integer, OUT content text)
 RETURNS record
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  SELECT
      INTO status, content
           result.status, result.content
      FROM public.delete_storage_object(bucket_name, object_path) AS result;
END;
$function$
"
public,fill_chunk_collection_if_exists,"CREATE OR REPLACE FUNCTION public.fill_chunk_collection_if_exists()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Look up collection name from collection_files if available
  SELECT name INTO NEW.collection
  FROM collection_files
  WHERE file_id = NEW.file_id
  LIMIT 1;

  RETURN NEW;
END;
$function$
"
public,fill_chunk_file_name,"CREATE OR REPLACE FUNCTION public.fill_chunk_file_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Look up the file name from the files table
  SELECT name INTO NEW.file_name
  FROM files
  WHERE id = NEW.file_id
  LIMIT 1;

  RETURN NEW;
END;
$function$
"
public,fill_name_everywhere,"CREATE OR REPLACE FUNCTION public.fill_name_everywhere()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  collection_name TEXT;
BEGIN
  -- Get the name from the collection
  SELECT name INTO collection_name
  FROM collections
  WHERE id = NEW.collection_id;

  -- Set it on collection_files row
  NEW.name := collection_name;

  -- Update all related document_chunks
  UPDATE document_chunks
  SET name = collection_name
  WHERE file_id = NEW.file_id;

  RETURN NEW;
END;
$function$
"
public,match_documents,"CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, user_id_filter uuid DEFAULT NULL::uuid, file_name_filter text DEFAULT NULL::text, collection_filter text DEFAULT NULL::text, description_filter text DEFAULT NULL::text, start_date timestamp without time zone DEFAULT NULL::timestamp without time zone, end_date timestamp without time zone DEFAULT NULL::timestamp without time zone, match_threshold double precision DEFAULT 0.3, match_count integer DEFAULT 500)
 RETURNS TABLE(id uuid, user_id uuid, created_at timestamp without time zone, content text, chunk_timestamp timestamp without time zone, file_id uuid, chunk_index integer, file_name text, openai_embedding vector, updated_at timestamp without time zone, sharing text, folder_id uuid, file_path text, type text, size integer, project_id uuid, message_index integer, topic_id uuid, embedding_json jsonb, session_id uuid, status text, topic_name text, speaker_role text, ingested boolean, ingested_at timestamp without time zone, uploaded_at timestamp without time zone, file_content text, score double precision)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        document_chunks.id,
        document_chunks.user_id,
        document_chunks.created_at::timestamp,
        document_chunks.content,
        document_chunks.""timestamp""::timestamp AS chunk_timestamp,
        document_chunks.file_id,
        document_chunks.chunk_index,
        document_chunks.file_name,
        document_chunks.openai_embedding,
        document_chunks.updated_at::timestamp,
        document_chunks.sharing,
        document_chunks.folder_id,
        document_chunks.file_path,
        document_chunks.type,
        document_chunks.size,
        document_chunks.project_id,
        document_chunks.message_index,
        document_chunks.topic_id,
        document_chunks.embedding_json,
        document_chunks.session_id,
        document_chunks.status,
        document_chunks.topic_name,
        document_chunks.speaker_role,
        document_chunks.ingested,
        document_chunks.ingested_at::timestamp,
        document_chunks.uploaded_at::timestamp,
        document_chunks.file_content,
        (1 - (document_chunks.openai_embedding <=> query_embedding)) AS score
    FROM document_chunks
    WHERE (user_id_filter IS NULL OR document_chunks.user_id = user_id_filter)
      AND (file_name_filter IS NULL OR document_chunks.file_name = file_name_filter)
      AND (collection_filter IS NULL OR document_chunks.collection = collection_filter)
      AND (description_filter IS NULL OR document_chunks.description ILIKE '%' || description_filter || '%')
      AND (start_date IS NULL OR document_chunks.created_at >= start_date)
      AND (end_date IS NULL OR document_chunks.created_at <= end_date)
      AND (document_chunks.openai_embedding <=> query_embedding) <= (1 - match_threshold)
    ORDER BY score DESC
    LIMIT match_count;
END;
$function$
"
public,match_documents_with_settings,"CREATE OR REPLACE FUNCTION public.match_documents_with_settings(query text)
 RETURNS TABLE(id uuid, document_id uuid, content text, similarity double precision)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
  settings RECORD;
BEGIN
  SELECT * INTO settings FROM search_settings LIMIT 1;

  RETURN QUERY
  SELECT * FROM match_documents(
    query,
    settings.similarity_threshold,
    settings.max_match_count,
    settings.default_file_name_filter,
    settings.default_collection_filter,
    settings.default_description_filter,
    settings.default_start_date,
    settings.default_end_date
  );
END;
$function$
"
public,match_file_items_openai,"CREATE OR REPLACE FUNCTION public.match_file_items_openai(query_embedding vector, match_count integer DEFAULT NULL::integer, file_ids uuid[] DEFAULT NULL::uuid[])
 RETURNS TABLE(id uuid, file_id uuid, content text, tokens integer, similarity double precision)
 LANGUAGE plpgsql
AS $function$
#variable_conflict use_column
begin
  return query
  select
    id,
    file_id,
    content,
    tokens,
    1 - (file_items.openai_embedding <=> query_embedding) as similarity
  from file_items
  where (file_id = ANY(file_ids))
    and 1 - (file_items.openai_embedding <=> query_embedding) > 0.8 -- MINIMUM RELEVANCE
  order by file_items.openai_embedding <=> query_embedding
  limit match_count;
end;
$function$
"
public,non_private_assistant_exists,"CREATE OR REPLACE FUNCTION public.non_private_assistant_exists(p_name text)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1
        FROM assistants
        WHERE (id::text = (storage.filename(p_name))) AND sharing <> 'private'
    );
$function$
"
public,non_private_file_exists,"CREATE OR REPLACE FUNCTION public.non_private_file_exists(p_name text)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1
        FROM files
        WHERE (id::text = (storage.foldername(p_name))[2]) AND sharing <> 'private'
    );
$function$
"
public,non_private_workspace_exists,"CREATE OR REPLACE FUNCTION public.non_private_workspace_exists(p_name text)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT EXISTS (
        SELECT 1
        FROM workspaces
        WHERE (id::text = (storage.filename(p_name))) AND sharing <> 'private'
    );
$function$
"
public,prevent_home_field_update,"CREATE OR REPLACE FUNCTION public.prevent_home_field_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.is_home IS DISTINCT FROM OLD.is_home THEN
    RAISE EXCEPTION 'Updating the home field of workspace is not allowed.';
  END IF;
  
  RETURN NEW;
END;
$function$
"
public,prevent_home_workspace_deletion,"CREATE OR REPLACE FUNCTION public.prevent_home_workspace_deletion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF OLD.is_home THEN
    RAISE EXCEPTION 'Home workspace deletion is not allowed.';
  END IF;
  
  RETURN OLD;
END;
$function$
"
public,set_chunk_relevant_date_on_insert,"CREATE OR REPLACE FUNCTION public.set_chunk_relevant_date_on_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  file_date DATE;
BEGIN
  SELECT relevant_date INTO file_date
  FROM files
  WHERE id = NEW.file_id;

  NEW.relevant_date := file_date;

  RETURN NEW;
END;
$function$
"
public,set_document_chunk_file_path,"CREATE OR REPLACE FUNCTION public.set_document_chunk_file_path()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    SELECT f.file_path
    INTO NEW.file_path
    FROM files f
    WHERE f.id = NEW.file_id AND f.user_id = NEW.user_id
    LIMIT 1;

    RETURN NEW;
END;
$function$
"
public,update_updated_at_column,"CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now(); 
    RETURN NEW; 
END;
$function$
"